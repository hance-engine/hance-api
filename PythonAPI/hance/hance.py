import ctypes
import os
import platform
import re

# Check for required modules and prompt to install if missing
try:
    import numpy as np
except ImportError:
    print("NumPy is not installed. Please install it using the command:")
    print("pip install numpy")
    exit()


MODULE_PATH = os.path.dirname(os.path.abspath(__file__))
MODEL_PATH = os.path.join(MODULE_PATH, "models")
BIN_PATH = os.path.join(MODULE_PATH, "bin")

if not os.path.exists(MODEL_PATH):
    # We run from the source folder in the github repo
    up_one_folder = os.path.split(MODULE_PATH)[0]
    two_up_folder = os.path.split(up_one_folder)[0]
    MODEL_PATH = os.path.join(two_up_folder, "Models")

if not os.path.exists(BIN_PATH):
    # We run from the source folder in the github repo
    up_one_folder = os.path.split(MODULE_PATH)[0]
    two_up_folder = os.path.split(up_one_folder)[0]
    BIN_PATH = os.path.join(two_up_folder, "Bin")

# Create a data structure to hold the pointer generated by hanceGetModelInfo...
HANCE_PARAM_MAXATTENUATION = 0x0001
HANCE_PARAM_SENSITIVITY = 0x0002
HANCE_PARAM_MASKEXTRAPOLATION = 0x0003
HANCE_PARAM_BUS_GAINS = 0x0100
HANCE_PARAM_BUS_SENSITIVITIES = 0x0200

class HanceEngine:
    """
    The HanceEngine is a machine learning audio enhancement module
    developed by Hance.ai
    """

    class Processor:
        def __init__(
            self,
            hance_engine: ctypes.CDLL,
            model_path: str,
            num_of_channels: int,
            sample_rate: float,
        ):
            self.hance_engine = hance_engine

            self.handle = self.hance_engine.hanceCreateProcessor(
                model_path.encode(), num_of_channels, sample_rate
            )
            if not self.handle:
                raise Exception("Unable to load HANCE model file.")
            self.num_of_channels = num_of_channels

        def __del__(self):
            self.hance_engine.hanceDeleteProcessor(self.handle)

        def process(self, audio_signal: np.array) -> bool:
            """
            Processes audio from a numpy array with the format [samples, channels]. The length of the processed audio
            will normally differ from the input lengt due to latency and block based processing.
            """
            num_of_input_samples = audio_signal.shape[0]
            interleaved_audio = audio_signal.astype(np.float32).flatten()
            self.hance_engine.hanceAddAudioInterleaved(
                self.handle,
                interleaved_audio.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
                num_of_input_samples,
            )
            num_of_output_samples = self.hance_engine.hanceGetNumOfPendingSamples(self.handle)
            if num_of_output_samples > 0:
                num_of_output_elements = self.num_of_channels * num_of_output_samples
                PCMArray = ctypes.c_float * num_of_output_elements
                pcm_out = PCMArray(*range(num_of_output_elements))
                self.hance_engine.hanceGetAudioInterleaved(
                    self.handle,
                    ctypes.cast(pcm_out, ctypes.POINTER(ctypes.c_float)),
                    num_of_output_samples,
                )
                return np.array(pcm_out).reshape(num_of_output_samples, self.num_of_channels)
            else:
                return np.empty((0, 0))

        def reset(self):
            self.hance_engine.hanceResetProcessor()

        def get_info(self):
            """
            Returns a processor_info dict with information about the processor.
            """

            processor_info = ProcessorInfo()
            self.hance_engine.hanceGetProcessorInfo(self.handle, ctypes.byref(processor_info))

            processor_info_parsed = {}
            for field in processor_info._fields_:
                processor_info_parsed[field[0]] = getattr(processor_info, field[0])
            return processor_info_parsed

        def get_max_attenuation(self) -> float:
            """
            Returns the current maximum attenuation setting in dB
            The valid value range is <-inf, 0]
            """
            return self.hance_engine.hanceGetParameterValue(self.handle, HANCE_PARAM_MAXATTENUATION)

        def set_max_attenuation(self, max_attenuation: float):
            """
            Sets the current maximum attenuation setting in dB
            The valid value range is <-inf, 0]
            """
            return self.hance_engine.hanceSetParameterValue(
                self.handle, HANCE_PARAM_MAXATTENUATION, max_attenuation
            )

        def get_sensitivity(self) -> float:
            """
            Returns the current sensitivity in percent. 0% is neutral and positive
            values will increase the amount of reduction.
            The valid value range is [-100, 100]
            """
            return self.hance_engine.hanceGetParameterValue(self.handle, HANCE_PARAM_SENSITIVITY)

        def set_sensitivity(self, sensitivity: float):
            """
            Sets the current sensitivity in percent. 0% is neutral and positive
            values will increase the amount of reduction.
            The valid value range is [-100, 100]
            """
            return self.hance_engine.hanceSetParameterValue(
                self.handle, HANCE_PARAM_SENSITIVITY, sensitivity
            )
        
        def get_output_bus_name(self, output_bus_index, max_length=256):
            """
            Returns the name of the specified output bus as a string.
            """
            # Create a buffer for the output bus name
            output_bus_name = (ctypes.c_char * max_length)()
            # Call the C function
            self.hance_engine.hanceGetOutputBusName(self.handle, output_bus_index, output_bus_name, max_length)
            # Convert the result to a Python string and return it
            return output_bus_name.value.decode('utf-8')
        
        def get_parameter_range(self, parameter_index):
            """
            Returns a dictionary with the min and max values for the specified parameter.
            """
            min_value = ctypes.c_float()
            max_value = ctypes.c_float()
            # Call the C function
            self.hance_engine.hanceGetParameterRange(self.handle, parameter_index, ctypes.byref(min_value), ctypes.byref(max_value))
            # Return a dictionary with the min and max values
            return {"minValue": min_value.value, "maxValue": max_value.value}
        
        def get_number_of_output_buses(self):
            """
            Returns the number of output buses for this processor.
            """
            return self.hance_engine.hanceGetNumOfOutputBusses(self.handle)

        def set_output_bus_volume(self, bus_index: int, volume: float):
            """
            Sets the volume for a specific output bus.
            
            Parameters:
                bus_index (int): The index of the output bus.
                volume (float): The volume to set for the output bus (usually 0 or above).
            """
            # Calculate the parameter index for the specific bus
            parameter_index = HANCE_PARAM_BUS_GAINS + bus_index
            # Set the volume using hanceSetParameterValue
            self.hance_engine.hanceSetParameterValue(self.handle, parameter_index, volume)

        def get_output_bus_volume(self, bus_index: int) -> float:
            """
            Gets the volume for a specific output bus.

            Parameters:
                bus_index (int): The index of the output bus.

            Returns:
                float: The current volume level of the specified output bus.
            """
            # Calculate the parameter index for the specific bus
            parameter_index = HANCE_PARAM_BUS_GAINS + bus_index
            # Get the volume using hanceGetParameterValue
            return self.hance_engine.hanceGetParameterValue(self.handle, parameter_index)

        def set_output_bus_sensitivity(self, bus_index: int, sensitivity: float):
            """
            Sets the sensitivity for a specific output bus.

            Parameters:
                bus_index (int): The index of the output bus.
                sensitivity (float): The sensitivity to set for the output bus, typically within a range like [-100, 100].
            """
            # Calculate the parameter index for the specific bus
            parameter_index = HANCE_PARAM_BUS_SENSITIVITIES + bus_index
            # Set the sensitivity using hanceSetParameterValue
            self.hance_engine.hanceSetParameterValue(self.handle, parameter_index, sensitivity)

                


    def __init__(self):
        path_to_binary = self.find_binary()
        
        if not path_to_binary:
            raise Exception("Could not find the HANCE Engine binary.")

        self.hance_engine = ctypes.cdll.LoadLibrary(path_to_binary)

        # HANCE_API bool hanceAddLicense (const char* licenseString);
        self.hance_engine.hanceAddLicense.argtypes = [ctypes.c_char_p]
        self.hance_engine.hanceAddLicense.restype = ctypes.c_bool

        # HANCE_API HanceProcessorHandle hanceCreateProcessor (const char* modelFilepath, int32_t numOfChannels, double sampleRate);
        self.hance_engine.hanceCreateProcessor.argtypes = [
            ctypes.c_char_p,
            ctypes.c_int32,
            ctypes.c_double,
        ]
        self.hance_engine.hanceCreateProcessor.restype = ctypes.c_void_p

        # HANCE_API HanceProcessorHandle hanceCreateStemSeparator (int32_t numOfModels, const char** modelFilepaths, int32_t numOfChannels, double sampleRate);
        # self.hance_engine.hanceCreateStemSeparator.argtypes = [ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32, ctypes.c_double]
        self.hance_engine.hanceCreateStemSeparator.argtypes = [
            ctypes.c_int32,
            ctypes.POINTER(ctypes.POINTER(ctypes.c_char)),
            ctypes.c_int32,
            ctypes.c_double,
        ]
        self.hance_engine.hanceCreateStemSeparator.restype = ctypes.c_void_p

        # HANCE_API HanceProcessorHandle hanceCreateProcessor (const char* modelFilepath, int32_t numOfChannels, double sampleRate);
        self.hance_engine.hanceCreateProcessor.argtypes = [
            ctypes.c_char_p,
            ctypes.c_int32,
            ctypes.c_double,
        ]
        self.hance_engine.hanceCreateProcessor.restype = ctypes.c_void_p

        # HANCE_API void hanceDeleteProcessor (HanceProcessorHandle processorHandle);
        self.hance_engine.hanceDeleteProcessor.argtypes = [ctypes.c_void_p]
        self.hance_engine.hanceDeleteProcessor.restype = None

        # HANCE_API void hanceAddAudioInterleaved (HanceProcessorHandle processorHandle, const float* interleavedPCM, int32_t numOfSamples);
        self.hance_engine.hanceAddAudioInterleaved.argtypes = [
            ctypes.c_void_p,
            ctypes.POINTER(ctypes.c_float),
            ctypes.c_int32,
        ]
        self.hance_engine.hanceAddAudioInterleaved.restype = None

        # HANCE_API int32_t hanceGetNumOfPendingSamples (HanceProcessorHandle processorHandle);
        self.hance_engine.hanceGetNumOfPendingSamples.argtypes = [ctypes.c_void_p]
        self.hance_engine.hanceGetNumOfPendingSamples.restype = ctypes.c_int32

        # HANCE_API bool hanceGetAudioInterleaved (HanceProcessorHandle processorHandle, float* interleavedPCM, int32_t numOfSamples);
        self.hance_engine.hanceGetAudioInterleaved.argtypes = [
            ctypes.c_void_p,
            ctypes.POINTER(ctypes.c_float),
            ctypes.c_int32,
        ]
        self.hance_engine.hanceGetAudioInterleaved.restype = ctypes.c_bool

        # HANCE_API void hanceResetProcessorState (HanceProcessorHandle modelHandle);
        self.hance_engine.hanceResetProcessorState.argtypes = [ctypes.c_void_p]
        self.hance_engine.hanceResetProcessorState.restype = None

        # HANCE_API void hanceGetProcessorInfo (HanceProcessorHandle modelHandle, HanceProcessorInfo* modelInfo);
        self.hance_engine.hanceGetProcessorInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        self.hance_engine.hanceGetProcessorInfo.restype = None

        # HANCE_API float hanceGetParameterValue (HanceProcessorHandle processorHandle, int32_t parameterIndex);
        self.hance_engine.hanceGetParameterValue.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        self.hance_engine.hanceGetParameterValue.restype = ctypes.c_float

        # HANCE_API void hanceSetParameterValue (HanceProcessorHandle processorHandle, int32_t parameterIndex, float parameterValue);
        self.hance_engine.hanceSetParameterValue.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_float,
        ]
        self.hance_engine.hanceSetParameterValue.restype = None

        # HANCE_API c_int32 hanceGetNumOfOutputBusses (HanceProcessorHandle modelHandle);
        self.hance_engine.hanceGetNumOfOutputBusses.argtypes = [ctypes.c_void_p]
        self.hance_engine.hanceGetNumOfOutputBusses.restype = ctypes.c_int32

        # Define the function's argument types and return type
        self.hance_engine.hanceGetOutputBusName.argtypes = [
            ctypes.c_void_p,  # HanceProcessorHandle processorHandle
            ctypes.c_int32,   # int32_t outputBusIndex
            ctypes.POINTER(ctypes.c_char),  # char* outputBusName
            ctypes.c_int32    # int32_t maxLength
        ]
        self.hance_engine.hanceGetOutputBusName.restype = None  # void function

        # Define the function's argument types and return type
        self.hance_engine.hanceGetParameterRange.argtypes = [
            ctypes.c_void_p,     # HanceProcessorHandle processorHandle
            ctypes.c_int32,      # int32_t parameterIndex
            ctypes.POINTER(ctypes.c_float),  # float* minimumValue
            ctypes.POINTER(ctypes.c_float)   # float* maximumValue
        ]
        self.hance_engine.hanceGetParameterRange.restype = None  # void function


        self.prev_samplerate = None
        self.prev_channels = None

    def add_license(self, license_string: str) -> bool:
        return self.hance_engine.hanceAddLicense(license_string.encode())

    def create_processor(
        self, model_file_path: str, num_of_channels: int, sample_rate: int
    ) -> Processor:
        """
        Creates an audio processor from a HANCE model file.
        """
        model_file_abs_path = get_model_file_abs_path(model_file_path)
        return self.Processor(self.hance_engine, model_file_abs_path, num_of_channels, sample_rate)

    def find_binary(self) -> str:
        """
        Returns the path to a binary in the bin folder.
        """

        relative_path = BIN_PATH
        
        path_to_binary = None
        if platform.system() == "Windows":
            if platform.architecture()[0] == "32bit":
                path_to_binary = os.path.join(relative_path, "Windows_x86/HanceEngine.dll")
            if platform.architecture()[0] == "64bit":
                path_to_binary = os.path.join(relative_path, "Windows_x64/HanceEngine.dll")
        elif platform.system() == "Darwin":
            fn = self.find_preferred_dylib(os.path.join(relative_path, "macOS"), "libHanceEngine")
            path_to_binary = os.path.join(relative_path, "macOS", fn)
        elif platform.system() == "Linux":
            path_to_binary = os.path.join(relative_path, "Linux_x64/libHanceEngine.so")

        return path_to_binary
    

    def find_preferred_dylib(self, directory, base_name):
        """
        Finds the preferred .dylib file in the directory.
        If a file with a version number exists, it returns that file.
        Otherwise, it returns the one without a version number.

        :param directory: The directory to search for .dylib files.
        :param base_name: The base name of the .dylib file (e.g., "libHanceEngine").
        :return: The path to the preferred .dylib file, or None if no matches are found.
        """
        versioned_pattern = re.compile(rf"{base_name}\.\d+\.\d+\.\d+\.dylib$")
        non_versioned_name = f"{base_name}.dylib"

        versioned_file = None
        non_versioned_file = None

        for file_name in os.listdir(directory):
            if versioned_pattern.match(file_name):
                versioned_file = os.path.join(directory, file_name)
            elif file_name == non_versioned_name:
                non_versioned_file = os.path.join(directory, file_name)

        return versioned_file or non_versioned_file



class ProcessorInfo(ctypes.Structure):
    _fields_ = [
        ("sampleRate", ctypes.c_double),
        ("numOfModelChannels", ctypes.c_int32),
        ("latencyInSamples", ctypes.c_int32),
        ("blockSize", ctypes.c_int32),
        ("hopSize", ctypes.c_int32),
    ]


class ProcessorSettings(ctypes.Structure):
    """creates a struct to match hanceProcessorSettings"""

    _fields_ = [
        ("sensitivity", ctypes.c_float),
        ("maximumAttenuation", ctypes.c_float),
    ]


def list_models():
    """
    Returns a list of available models.
    """
    model_list = []
    
    for fn in os.listdir(MODEL_PATH):
        if fn.endswith(".hance"):
            model_list.append(fn)
    return model_list


def update_models():
    """
    Updates the local models directory by downloading the latest public branch archive
    from the HANCE models GitHub repository using urllib.
    """
    import urllib.request
    import zipfile
    import io
    import os

    repo_url = "https://github.com/hance-engine/hance-api/archive/refs/heads/main.zip"  # Update with the latest public branch URL if different
    models_dir = os.path.abspath(MODEL_PATH)  # Absolute path to the local Models directory
    
    print("Downloading the latest models archive...")
    try:
        # Download the repository archive
        with urllib.request.urlopen(repo_url) as response:
            if response.status != 200:
                raise Exception(f"Failed to download archive: HTTP {response.status}")
            
            # Read the archive into memory
            archive_data = response.read()
        
        # Extract the downloaded archive
        with zipfile.ZipFile(io.BytesIO(archive_data)) as z:
            extracted_base = z.namelist()[0]  # First directory in the archive
            extracted_models_prefix = os.path.join(extracted_base, "Models")

            if not os.path.exists(models_dir):
                os.makedirs(models_dir)

            # Extract only the contents of the Models directory
            for file in z.namelist():
                if file.startswith(extracted_models_prefix):
                    # Compute the relative path inside the Models folder
                    relative_path = os.path.relpath(file, extracted_models_prefix)
                    if relative_path == ".":  # Skip the root directory itself
                        continue
                    
                    # Compute the target path
                    target_path = os.path.join(models_dir, relative_path)

                    # Create directories or write files as needed
                    if file.endswith('/'):
                        os.makedirs(target_path, exist_ok=True)  # Create directories
                    else:
                        with open(target_path, "wb") as f:
                            f.write(z.read(file))

        print(f"Models updated successfully at {models_dir}.")
    except Exception as e:
        print(f"Error updating models: {e}")
        raise

def get_model_file_abs_path(model_file_path: str):
    model_file_abs_path = model_file_path
    if not os.path.exists(model_file_abs_path):
        # possible a relative path from list_models
        found_model = False

        model_file_abs_path = os.path.join(MODEL_PATH, model_file_path)
        if os.path.exists(model_file_abs_path):
            found_model = True

        if not found_model:
            raise Exception("Model file does not exist.")

    return model_file_abs_path
